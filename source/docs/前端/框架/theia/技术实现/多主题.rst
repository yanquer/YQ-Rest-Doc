===================================
多主题
===================================

主要::

  node_modules/@theia/core/src/browser/theming.ts

下定义的 ThemeService 服务.

在 init 方法中注册了默认主题::

  protected init(): void {
    this.register(...BuiltinThemeProvider.themes);
    ...

可以看到默认主题定义::

  export class BuiltinThemeProvider {

      static readonly darkTheme: Theme = {
          id: 'dark',
          type: 'dark',
          label: 'Dark (Theia)',
          editorTheme: 'dark-theia' // loaded in /packages/monaco/src/browser/textmate/monaco-theme-registry.ts
      };

      static readonly lightTheme: Theme = {
          id: 'light',
          type: 'light',
          label: 'Light (Theia)',
          editorTheme: 'light-theia' // loaded in /packages/monaco/src/browser/textmate/monaco-theme-registry.ts
      };

      static readonly hcTheme: Theme = {
          id: 'hc-theia',
          type: 'hc',
          label: 'High Contrast (Theia)',
          editorTheme: 'hc-theia' // loaded in /packages/monaco/src/browser/textmate/monaco-theme-registry.ts
      };

      static readonly hcLightTheme: Theme = {
          id: 'hc-theia-light',
          type: 'hcLight',
          label: 'High Contrast Light (Theia)',
          editorTheme: 'hc-theia-light' // loaded in /packages/monaco/src/browser/textmate/monaco-theme-registry.ts
      };

      static readonly themes = [
          BuiltinThemeProvider.darkTheme,
          BuiltinThemeProvider.lightTheme,
          BuiltinThemeProvider.hcTheme,
          BuiltinThemeProvider.hcLightTheme
      ];
  }

看注释, 都是在 `packages/monaco/src/browser/textmate/monaco-theme-registry.ts` 定义注册的::

    @injectable()
    export class MonacoThemeRegistry {

        @inject(TextmateRegistryFactory) protected readonly registryFactory: TextmateRegistryFactory;

        initializeDefaultThemes(): void {
            this.register(require('../../../data/monaco-themes/vscode/dark_theia.json'), {
                './dark_vs.json': require('../../../data/monaco-themes/vscode/dark_vs.json'),
                './dark_plus.json': require('../../../data/monaco-themes/vscode/dark_plus.json')
            }, 'dark-theia', 'vs-dark');
            this.register(require('../../../data/monaco-themes/vscode/light_theia.json'), {
                './light_vs.json': require('../../../data/monaco-themes/vscode/light_vs.json'),
                './light_plus.json': require('../../../data/monaco-themes/vscode/light_plus.json'),
            }, 'light-theia', 'vs');
            this.register(require('../../../data/monaco-themes/vscode/hc_theia.json'), {
                './hc_black.json': require('../../../data/monaco-themes/vscode/hc_black.json')
            }, 'hc-theia', 'hc-black');
            this.register(require('../../../data/monaco-themes/vscode/hc_theia_light.json'), {
                './hc_light.json': require('../../../data/monaco-themes/vscode/hc_light.json')
            }, 'hc-theia-light', 'hc-light');
        }

以 `dark_vs.json` 为例, 其中颜色定义为::

    {
        "$schema": "vscode://schemas/color-theme",
        "name": "Dark (Visual Studio)",
        "colors": {
            "editor.background": "#1E1E1E",
            "editor.foreground": "#D4D4D4",

    ...

可以看到颜色定义为类似于::

    editor.background

的样式, 但是实际使用的时候, 是::

    --editor-background

的样式, 那么是在哪里转换的?

有几个地方

- theia-core模块的定义1_
- theia-core模块的定义2_
- vs的editor下面的转换_

theia-core模块的定义1
===================================

这个的触发方式是 `node_modules/@theia/core/src/browser/color-application-contribution.ts`
定义的事件::

    @injectable()
    export class ColorApplicationContribution implements FrontendApplicationContribution {

        ...

        onStart(): void {
            for (const contribution of this.colorContributions.getContributions()) {
                contribution.registerColors(this.colors);
            }
            this.themeService.initialized.then(() => this.update());
            this.themeService.onDidColorThemeChange(() => {
                this.update();
                this.updateThemeBackground();
            });

        protected update(): void {
            this.toUpdate.dispose();
            this.windows.forEach(win => this.updateWindow(win));
            this.onDidChangeEmitter.fire();
        }

        protected updateWindow(win: Window): void {
            const theme = 'theia-' + this.themeService.getCurrentTheme().type;

            win.document.body.classList.add(theme);
            this.toUpdate.push(Disposable.create(() => win.document.body.classList.remove(theme)));

            const documentElement = win.document.documentElement;
            if (documentElement) {
                for (const id of this.colors.getColors()) {
                    const variable = this.colors.getCurrentCssVariable(id);
                    if (variable) {
                        const { name, value } = variable;
                        documentElement.style.setProperty(name, value);
                        this.toUpdate.push(Disposable.create(() => documentElement.style.removeProperty(name)));
                    }
                }
            }
        }

    }

如何实现 **动态属性切换** 也在这::

    documentElement.style.setProperty(name, value);

这里会拿到CSS属性名, 与对应颜色值, 使用 `documentElement.style.setProperty` 动态设置进去.

可以通过跟断点验证这一点.

.. figure:: ../../../../../resources/images/2024-03-08-16-23-10.png
    :width: 480px


`const variable = this.colors.getCurrentCssVariable(id);` 调到的是
`node_modules/@theia/core/src/browser/color-registry.ts` 的 `ColorRegistry`::

    @injectable()
    export class ColorRegistry {

        getCurrentCssVariable(id: string): ColorCssVariable | undefined {
            const value = this.getCurrentColor(id);
            if (!value) {
                return undefined;
            }
            const name = this.toCssVariableName(id);
            return { name, value };
        }

        toCssVariableName(id: string, prefix = 'theia'): string {
            return `--${prefix}-${id.replace(/\./g, '-')}`;
        }

    }

结论
    会在theia自定义的样式前加上 `--theia-` 前缀, 并把 `.` 转换为 `-`


theia-core模块的定义2
===================================

这里主要讲如何讲 json 的内容完整的注册进去.
如果是一个完全自定义的样式变量, 光写json是不行的.

以下面的两个自定义颜色变量为例::

    {
        "$schema": "vscode://schemas/color-theme",
        "name": "Dark (Custom)",
        "colors": {
            "ideC.editor.background": "#1E1E1E",
            "ideC.editor.foreground": "#D4D4D4",

    ...

还需要将这个变量注册进去, 注册实现位于 `node_modules/@theia/core/src/browser/color-application-contribution.ts` 的
`ColorContribution` 贡献点的 `registerColors` 即可::

    import {ColorContribution} from "@theia/core/lib/browser/color-application-contribution";
    import {ColorRegistry} from "@theia/core/lib/browser/color-registry";
    import {ColorDefinition} from "@theia/core/src/common/color";

    // "ideC.editor.background": "#1E1E1E",
    // "ideC.editor.foreground": "#D4D4D4",

    class CustomColor implements ColorContribution{

        private customColorID: ColorDefinition[] = [
            {id: "ideC.editor.background", description: "color 1"},
            {id: "ideC.editor.foreground", description: "color 2"},
        ]

        registerColors(colors: ColorRegistry): void {
            colors.register(...this.customColorID)
        }

    }

.. warning::

    只有注册到贡献点的id, 才会去json里面找

主要是调用的 `node_modules/@theia/monaco-editor-core/src/vs/platform/theme/common/colorRegistry.ts`下
`ColorRegistry` 的 `registerColor`. 可以理解这个 `ColorRegistry()` 是一个缓存,
json里面的配置会先读到这里, 然后在 theia-core模块的定义1_ 中需要 `documentElement.style.setProperty`
的时候再从这个缓存里读.

vs的editor下面的转换
===================================

主要文件:
    `node_modules/@theia/monaco-editor-core/src/vs/editor/standalone/browser/standaloneThemeService.ts`

位于 `node_modules/@theia/monaco-editor-core/src/vs/editor/standalone/browser/standaloneThemeService.ts`
下 `StandaloneThemeService` 的 `_updateThemeOrColorMap` ::

    const colorVariables: string[] = [];
    for (const item of colorRegistry.getColors()) {
        const color = this._theme.getColor(item.id, true);
        if (color) {
            colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);
        }
    }

主要是 `asCssVariableName`, 看看它的定义::

    export function asCssVariableName(colorIdent: ColorIdentifier): string {
        return `--vscode-${colorIdent.replace(/\./g, '-')}`;
    }


结论
    会在vscode的样式前加上 `--vscode-` 前缀, 并把 `.` 转换为 `-`

那么vscode的主题是怎么实现动态设置的呢?

在 `node_modules/@theia/monaco-editor-core/src/vs/editor/browser/editorDom.ts` 下的
`RefCountedCssRule` ::

    class RefCountedCssRule {
        private _referenceCount: number = 0;
        private _styleElement: HTMLStyleElement;

        constructor(
            public readonly key: string,
            public readonly className: string,
            _containerElement: HTMLElement | undefined,
            public readonly properties: CssProperties,
        ) {
            this._styleElement = dom.createStyleSheet(
                _containerElement
            );

            this._styleElement.textContent = this.getCssText(this.className, this.properties);
        }

        private getCssText(className: string, properties: CssProperties): string {
            let str = `.${className} {`;
            for (const prop in properties) {
                const value = (properties as any)[prop] as string | ThemeColor;
                let cssValue;
                if (typeof value === 'object') {
                    cssValue = `var(${asCssVariableName(value.id)})`;
                } else {
                    cssValue = value;
                }

                const cssPropName = camelToDashes(prop);
                str += `\n\t${cssPropName}: ${cssValue};`;
            }
            str += `\n}`;
            return str;
        }

        public dispose(): void {
            this._styleElement.remove();
        }
        ...

    }

其中 `getCssText` 就是拿到上面所说的所有转换vs的样式字符串, 主要看
位于 `node_modules/@theia/monaco-editor-core/src/vs/base/browser/dom.ts`
的 `_styleElement` 的创建::

    export function createStyleSheet(container: HTMLElement = document.getElementsByTagName('head')[0]): HTMLStyleElement {
        const style = document.createElement('style');
        style.type = 'text/css';
        style.media = 'screen';
        container.appendChild(style);
        return style;
    }

与theia不同, 它是直接生成一个style然后写进去.


颜色与主题区别
===================================

主题注册与切换基本是通过 `node_modules/@theia/monaco-editor-core/src/vs/editor/standalone/browser/standaloneEditor.ts`
下的这两::

    /**
    * Define a new theme or update an existing theme.
    */
    export function defineTheme(themeName: string, themeData: IStandaloneThemeData): void {
        const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
        standaloneThemeService.defineTheme(themeName, themeData);
    }

    /**
    * Switches to a theme.
    */
    export function setTheme(themeName: string): void {
        const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
        standaloneThemeService.setTheme(themeName);
    }

理一下 **主题** 与 **颜色** 的区别

主题包含颜色, 与颜色定义,
但是使用的时候, 是根据注册了哪些颜色, 使用主题里的颜色.

即 只有通过  `node_modules/@theia/core/src/browser/color-application-contribution.ts` 的
`ColorContribution` 贡献点的 `registerColors` 注册的颜色.

下面的 colors 才能生效::

    {
        "$schema": "vscode://schemas/color-theme",
        "name": "Dark (Custom)",
        "colors": {
            "ideC.editor.background": "#1E1E1E",
            "ideC.editor.foreground": "#D4D4D4",

    ...

除非是内部已经注册的.

vscode主题与theia主题的区别
===================================

默认情况下, vscode只会处理vscode相关的样式. `StandaloneThemeService` 上就是这样实例::

    function getBuiltinRules(builtinTheme: BuiltinTheme): IStandaloneThemeData {
        switch (builtinTheme) {
            case VS_LIGHT_THEME_NAME:
                return vs;
            case VS_DARK_THEME_NAME:
                return vs_dark;
            case HC_BLACK_THEME_NAME:
                return hc_black;
            case HC_LIGHT_THEME_NAME:
                return hc_light;
        }
    }

    function newBuiltInTheme(builtinTheme: BuiltinTheme): StandaloneTheme {
        const themeData = getBuiltinRules(builtinTheme);
        return new StandaloneTheme(builtinTheme, themeData);
    }

即只处理这四个主题.

另外还有一个 `StandaloneThemeService` 内的 `defineTheme`::

    public defineTheme(themeName: string, themeData: IStandaloneThemeData): void {
        if (!/^[a-z0-9\-]+$/i.test(themeName)) {
            throw new Error('Illegal theme name!');
        }
        if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
            throw new Error('Illegal theme base!');
        }
        // set or replace theme
        this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));

        ...
    }

这里 this._knownThemes 也会实例一个新的.
而调用到这的条件还是 `node_modules/@theia/monaco/src/browser/textmate/monaco-theme-registry.ts`
下 `register` 的::

    register(json: any, includes?: { [includePath: string]: any }, givenName?: string, monacoBase?: monaco.editor.BuiltinTheme): ThemeMix {
        const name = givenName || json.name!;
        ...

        if (monacoBase && givenName) { ... }

        ...

    }

从这一点看, 很多样式在注册主题的时候,
只要定义了 `monacoBase` 是基于vs的, 就会同时包含 ``--theia-xxx`` 与 ``--vscode-xxx``.
不过只有setTheme才会触发 `--vscode-xxx` 的生成, 算是一种懒加载.
同时, 由于加载顺序的原因, 往往首次加载只会生成vs主题的 `--vscode-xxx` 样式, 因为这个时候 colors 还没有注册上去,
而注册 colors 时, 因为主题已经设置好了, 就不会再 settheme 生成 `--vscode-xxx` 样式了, 除非手动切换一下主题.

故, 自定义的颜色, 还是使用 `--theia-xxx` 来使用

注意, **注册主题与注册颜色是两个调用**


.. .. note:\:

..     注意这里是 `colorRegistry.getColors()`, 获取的跟上面theia用的不是一个缓存,
..     theia用的是:\:

..         public getColorSchema(): IJSONSchema {
..             return this.colorSchema;
..         }

..     而这用的是:\:

..         public getColors(): ColorContribution[] {
..             return Object.keys(this.colorsById).map(id => this.colorsById[id]);
..         }

..     这也是两者的区别

