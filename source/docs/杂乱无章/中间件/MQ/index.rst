==============================
MQ
==============================


.. post:: 2024-03-09 18:21:01
  :tags: MQ
  :category: 中间件
  :author: YanQue
  :location: CD
  :language: zh-cn


.. toctree::
  :maxdepth: 1

  RocketMQ

主要是适用于分布式微服务场景下的,
单体小业务用不到.

- 消息队列（Message Queue，简称MQ）指保存消息的一个容器，其实本质就是一个保存数据的队列;
- 消息中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的构建
- 消息中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削峰等问题，
  实现高性能，高可用，可伸缩和最终一致性的系统架构。
  目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。

主要用途
==============================

解耦
  将原来单体量应用拆分为分布式微服务架构, 通过MQ消息队列通信,
  提高可维护性.

  系统之间耦合转移为与MQ的耦合
异步
  避免完全串行化, 提高效率
削峰
  当某个时段请求量, 并发量大时, 给到消息队列里面去, 慢慢处理,
  不至于被搞挂掉.

异步解耦举例
------------------------------

在正常业务流程中，比较耗时而且不需要即时返回结果的操作。
将这些操作可以做为「异步处理」，这样可以大大的加快请求的响应时间。

最常见的场景就是用户注册之后，需要发送注册短信、邮件通知，以告知相关信息。

正常做法，是要经过三大步处理：用户信息处理、发送邮件、发送短信，
等这三步全部都完成之后，才返回前端，告诉你注册成功了。

使用MQ，只需要在处理完用户信息之后，
给MQ发送两个消息即可，邮件服务、短信服务监听MQ的任务消息，根据消息进行发送即可。

解耦微服务举例
------------------------------

还是用户注册的例子，将用户注册、邮件/短信发送理解为两个独立的微服务，就非常好理解

流量削峰填谷
------------------------------

控制流量，也是MQ比较常用的一个场景，一般在秒杀、搞活动中使用广泛。
这个时候一般用户请求量会激增，可能会远超当前系统的最大处理量，如果不做任何处理，系统可能就会宕掉。

使用MQ，可以将需要处理的消息全部放入其中，系统按照最大处理能力，
去获取消息进行消费，这样就可以将一瞬间过来的请求，分散到一段时间内进行处理，避免了系统的崩溃。

消息分发
------------------------------

这个也挺常用。多个系统对同一个数据感兴趣，只需要监听同一类消息即可。

例如付款系统，在付款成功之后，正常做法是通知外围系统这个单子付款成功了，
或者是外围系统定时来拉取付款结果，
使用MQ后，付款系统可以在付款成功之后，将消息放到MQ里面，
想知道这个结果的系统订阅这个主题的消息即可，非常方便，也不需要定时去拉取数据了。

事务消息发送步骤如下
  - 发送方将半事务消息发送至消息队列RocketMQ。
  - 消息队列RocketMQ将消息持久化成功之后，向发送方返回Ack确认消息已经发送成功，此时消息为半事务消息。
  - 发送方开始执行本地事务逻辑。
  - 发送方根据本地事务执行结果向服务端提交二次确认（Commit或是Rollback），
    服务端收到Commit状态则将半事务消息标记为可投递，订阅方最终将收到该消息；
    服务端收到Rollback状态则删除半事务消息，订阅方将不会接受该消息。

事务消息回查步骤如下：
  - 在断网或者是应用重启的特殊情况下，
    上述步骤4提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。
  - 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
  - 发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行操作。

缺点
==============================

系统可用性降低
  系统可用性在某种程度上降低。在加入MQ之前，
  你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！
系统复杂性提高
  重复消费、消息丢失、消息的顺序消费等等，反正用了之后就是贼烦。
数据一致性
  分布式服务本身就存在的一个问题，不仅仅是消息队列的问题，
  但是放在这里说是因为用了消息队列这个问题会暴露得比较严重一点

  有一个解决方案是 **分布式事务**:
  把相关操作如 下单，优惠券，积分。。。 都放在一个事务里面一样，要成功一起成功，要失败一起失败。

消息队列MQ设计
==============================

大致流程::

  Producer  ----send---->  Broker ----receive---->  Consumer

                                  消息存储
                                    --消息消费-->
                                    <--消息确认--
                                  消息备份/删除

- Producer 消息生产者：负责产生和发送消息到 Broker；
- Broker 消息处理中心：负责消息存储、确认、重试等，一般其中会包含多个 queue；
- Consumer 消息消费者：负责从 Broker 中获取消息，并进行相应处理；

分类
==============================

- Kafka
- ActiveMQ
- RabbitMQ
- RocketMQ
- 等这几种

ActiveMQ和RabbitMQ这两着因为吞吐量还有GitHub的社区活跃度的原因，
在各大互联网公司都已经基本上绝迹了，
业务体量一般的公司会是有在用的，
但是越来越多的公司更青睐RocketMQ这样的消息中间件了。

没有最好的技术，只有最适合的技术，不要为了用而用

ActiveMQ
------------------------------

优点

- 单机吞吐量：万级
- 时效性：ms级
- 可用性：高，基于主从架构实现高可用性
- 消息可靠性：有较低的概率丢失数据
- 功能支持：MQ领域的功能极其完备

缺点:

- 官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。

Kafka
------------------------------

号称大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，
这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，
迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。

Apache Kafka它最初由LinkedIn公司基于独特的设计实现为
一个分布式的提交日志系统( a distributed commit log)，之后成为Apache项目的一部分。

目前已经被LinkedIn，Uber, Twitter, Netflix等大公司所采纳。

优点

- 性能卓越，单机写入TPS约在百万条/秒(集群, 单机只有十万)，最大的优点，就是吞吐量高。
- 时效性：ms级
- 可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用
- 消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;
- 有优秀的第三方Kafka Web管理界面Kafka-Manager；
- 在日志领域比较成熟，被多家公司和多个开源项目使用；
- 功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用

缺点：

- Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长
- 使用短轮询方式，实时性取决于轮询间隔时间；

RabbitMQ
------------------------------

RabbitMQ 2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，
可复用的企业消息系统，是当前最主流的消息中间件之一。


RabbitMQ优点：

- 由于erlang语言的特性，mq 性能较好，高并发；
- 吞吐量到万级，MQ功能比较完备
- 健壮、稳定、易用、跨平台、支持多种语言、文档齐全；
- 开源提供的管理界面非常棒，用起来很好用
- 社区活跃度高；

RabbitMQ缺点：

- erlang开发，很难去看懂源码，基本只依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。
- RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。
- 需要学习比较复杂的接口和协议，学习和维护成本较高。

RocketMQ
------------------------------

RocketMQ出自 阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。

RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。

RocketMQ优点：

- 单机吞吐量：十万级
- 可用性：非常高，分布式架构
- 消息可靠性：经过参数优化配置，消息可以做到0丢失
- 功能支持：MQ功能较为完善，还是分布式的，扩展性好
- 支持10亿级别的消息堆积，不会因为堆积导致性能下降
- 源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控

RocketMQ缺点：

- 支持的客户端语言不多，目前是java及c++，其中c++不成熟；
- 社区活跃度一般
- 没有在 mq 核心中去实现JMS等接口，有些系统要迁移需要修改大量代码

消息队列选择建议
==============================

Kafka
  Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，
  一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。

  大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。
RocketMQ
  天生为金融互联网领域而生，对于可靠性要求很高的场景，
  尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。

  RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，
  如果你的业务有上述并发场景，建议可以选择RocketMQ。
RabbitMQ
  结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。
  不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。

  如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。





参考
  - `秒懂消息队列MQ，万字总结带你全面了解消息队列MQ <https://developer.aliyun.com/article/953777>`_
  - `消息队列（MQ）到底能干什么？  <https://zhuanlan.zhihu.com/p/362154896>`_
  - `深入消息队列MQ，看这篇就够了！ <https://zhuanlan.zhihu.com/p/431149128>`_
