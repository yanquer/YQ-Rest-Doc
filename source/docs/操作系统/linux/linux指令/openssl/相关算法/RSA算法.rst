=======================
RSA算法
=======================

参考:

- https://zhuanlan.zhihu.com/p/48249182 (RSA这个写的比较详细, 但是看着头疼, 后面有空继续看)
- https://www.openssl.net.cn/docs/3.html (这个是详细的中文说明, 没空看)

属于 **公钥加密算法**、 **非对称加密算法**

模运算
=======================

模运算即求余运算。“模”是“Mod”的音译。
和模运算紧密相关的一个概念是“同余”。
数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。

两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作::

  a ≡ b (mod m)

读作：a同余于b模m，或者，a与b关于模m同余。例如::

  26 ≡ 14 (mod 12)。

互质关系
=======================

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。
比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。

.. _互质关系结论:

关于互质关系，不难得到以下结论：
  a. 任意两个质数构成互质关系，比如13和61。
  #. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。
  #. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。
  #. 1和任意一个自然数是都是互质关系，比如1和99。
  #. p是大于1的整数，则p和p-1构成互质关系，比如57和56。
  #. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。

欧拉函数
=======================

思考以下问题::
  任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）

计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。

第一种情况
-----------------------

如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。

第二种情况
-----------------------

如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。

第三种情况
-----------------------

如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则

.. math::

  \varphi(n) = \varphi(p^k) = p^k - p^{k-1}

比如::

  φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。

这是因为只有当一个数不包含质数p(包含是指是质数p的倍数)，
才可能与n互质(因为若一个数包含质数p, 则不满足 互质关系结论_ 第二点).

而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、...、p^(k-1)×p, 这里可以推导::

  - 第一个数是1xp, 是第一个
  - 第二个数是2xp, 是第二个
  - \.\.\.
  - 最后一个数是p^(k-1)×p, 是第p^(k-1)个

故一共有 ``p^(k-1)`` 个包含p的数.

把它们去除，剩下的就是与n互质的数。
上面的式子还可以写成下面的形式:

.. math::

  \varphi(n) = \varphi(p^k) = p^k - p^{k-1} = p^k(1-\frac{1}{p})

可以看出，上面的第二种情况是 k=1 时的特例。

第四种情况
-----------------------

如果n可以分解成两个互质的整数之积::

  n = p1 × p2

则::

  φ(n) = φ(p1p2) = φ(p1)φ(p2)

即积的欧拉函数等于各个因子的欧拉函数之积。比如::

  φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。

这一条的证明要用到“中国剩余定理”，这里就不展开了，只简单说一下思路:

如果a与p1互质(a < p1)，b与p2互质(b < p2)，c与p1p2互质(c < p1p2)，则c与数对 (a,b) 是一一对应关系。
由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，
所以φ(p1p2)就等于φ(p1)φ(p2)。

第五种情况
-----------------------

因为任意一个大于1的正整数，都可以写成一系列质数的积

.. math::

  n = p_1^{k1} p_2^{k2} ... p_r^{kr}

根据 第四种情况_ 结论，得到

.. math::

  \varphi(n) = \varphi(p_1^{k1}) \varphi(p_2^{k2}) ... \varphi(p_r^{kr})


再根据 第三种情况_ 的结论，得到

.. math::

  \varphi(n) = p_1^{k1}(1-\frac{1}{p_1}) p_2^{k2}(1-\frac{1}{p_2}) ... p_r^{kr}(1-\frac{1}{p_r})

也就等于

.. math::

  \varphi(n) = n (1-\frac{1}{p_1}) (1-\frac{1}{p_2}) ... (1-\frac{1}{p_r})

这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下

.. math::

  \varphi(1323) = \varphi(3^3 x 7^2) = 1323(1-\frac{1}{3})(1-\frac{1}{7}) = 756

欧拉定理
=======================

欧拉函数的用处，在于欧拉定理。”欧拉定理”指的是: 如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立

.. math::

  a^{\varphi(n)} \equiv 1 \ (mod \ n)

也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。
比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。

欧拉定理有一个特殊情况。
`假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成`

.. math::

  a^{p-1} \equiv 1 \ (mod \ p)

这就是著名的费马小定理。它是欧拉定理的特例。

欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。

模反元素
=======================

还剩下最后一个概念：
`如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除，或者说ab被n除的余数是1.`

这时，b就叫做a的“模反元素”。

比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。
显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，
即如果b是a的模反元素，则 b+kn 都是a的模反元素。

欧拉定理可以用来证明模反元素必然存在。

可以看到，a的 φ(n)-1 次方，就是a的模反元素。

.. _R_RSA生成算法:

RSA生成算法
=======================

具体来说:

a. 选择两个大素数p和q,计算n=pq,且欧拉函数φ(n)=(p-1)(q-1)
#. 选择与φ(n)互质的整数e,e就是公钥指数
#. 计算d,满足ed≡1(mod φ(n)),d就是私钥指数
#. (n,e)就是公钥,(n,d)就是私钥

这里公钥(n,e)是从私钥(n,d)推导计算出来的,而无法由公钥反推私钥。

举个简单例子::

  p=5,q=7
  n=5*7=35
  φ(n)=(p-1)(q-1)=4*6=24

选择e=7,与24互质, 则d=7的乘法逆元mod 24=29, 则:

- 公钥(n=35, e=7)
- 私钥(n=35, d=29)

可以看出,公钥是从选择的d计算得到的e,但无法由e反推出d。
所以,RSA算法要求私钥生成公钥,而不能由公钥生成私钥,这是RSA算法的基本原理和要求。


