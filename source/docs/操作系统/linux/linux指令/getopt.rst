
============================
getopt
============================

getopt选项字符串:
  "a:b:cd::e"，这就是一个选项字符串。对应到命令行就是-a ,-b ,-c ,-d, -e 。
  冒号又是什么呢？ 冒号表示参数，
  一个冒号就表示这个选项后面必须带有参数（没有带参数会报错哦），
  但是这个参数可以和选项连在一起写，也可以用空格隔开，比如-a123 和-a   123（中间有空格） 都表示123是-a的参数；
  两个冒号的就表示这个选项的参数是可选的，即可以有参数，也可以没有参数，
  但要注意有参数时，参数与选项之间不能有空格（有空格会报错），这一点和一个冒号时是有区别的。

  -o或--options选项后面是可接受的短选项，如ab:c::，表示可接受的短选项为-a -b -c，其中-a选项不接参数，-b选项后必须接参数，-c选项的参数为可选的
  -l或--long选项后面是可接受的长选项，用逗号分开，冒号的意义同短选项。
  -n选项后接选项解析错误时提示的脚本名字


常用参数
============================

-a      允许长选项以单个字符”-“开始
-n      指定一个程序，供getopt(3)函数输出错误信息时使用
-o      识别单字符的短选项
-q      禁止输出错误信息
-l      识别多字符的长选项

自己写过的一个例子, **至少需要一个短选项**::

  #sh ./test.sh -l --warn ww --error ee --info ii --fatal ff

  # ARGS="getopt -o h -l warn:,error:,info:,fatal: -- $@"
  # eval set -- "${ARGS}"

  getopt -o h -l warn:,error:,info:,fatal: -- $@

  while true
  do
      case "$1" in
          --warn)
              echo "warn: i am $2"
              shift 2
              ;;
          --error)
              echo "error: i am $2"
              shift 2
              ;;
          --info)
              echo "info: i am $2"
              shift 2
              ;;
          --fatal)
              echo "fatal: i am $2"
              shift 2
              ;;
          --)
              shift
              break
              ;;
          *)
              echo "error---$1 $2"
              break
              ;;
      esac
  done

getopt的区别与分类
============================

上述例子有问题, 此处再重新介绍一下.

getopt有三种

- getopt标准版: 只能识别短选项;
- getopt增强版: 短选项长选项皆可;
- getopts: 只能识别短选项(严格来说可能也不能放在这)

其中, 识别getopt是标准版还是增强版可使用-T::

  getopt -T

标准版输出如下::

  $ getopt -T
  --
  $ echo $?
  0

增强版输出如下::

  root@67a43e314058:~# getopt -T
  root@67a43e314058:~# echo $?
  4

下面代码基于增强版编写,

.. literalinclude:: ../../../../resources/code/t_getopt.sh

注意对选项参数的定义::

  ARGS=$(getopt -o hu: -l help,user:,age:,name:: -- "$@")

长选项使用 `--long` 或 `-l` 皆可, 测试::

  root@67a43e314058:~# sh t_getopt.sh -u yq --name=11 --age 10
  ARGS:::  -u 'yq' --name '11' --age '10' --
  user:yq
  age:10
  name:11
  root@67a43e314058:~# sh t_getopt.sh -u yq --name 11 --age 10
  ARGS:::  -u 'yq' --name '' --age '10' -- '11'
  user:yq
  age:10
  name:

可以看出 `--name=11` 与 `--name 11` 的结果是不一样的, 后者没有成功赋值到name,
这是因为getopt解析时限定为 ``name::`` (双冒号).

两个冒号表示参数可选, 在debian11上默认空格选择的是非选项参数(不知其他系统是不是亦是).
如果要规避可以使用一个冒号表示参数必选.

.. note::

  无冒号表示选项不带参数;
  一个冒号表示选项必须指定参数;
  两个冒号表示选项参数可选.

getopt作用说明
============================

从上一节 getopt的区别与分类_ 的例子中可以看出,
其作用只是对命令行输入的参数做了一个校验与规范化,
实际 ``eval set -- "${ARGS}"`` 前后的 `ARGS` 都是一致的,
那么这句eval 是不是必须的呢?

是.

``eval set -- "${ARGS}"`` 的作用是将 ``${ARGS}`` 中的字符串解析为命令行参数，并赋值给脚本中的位置参数。

- ``"${ARGS}"`` 使用双引号将整个字符串括起来，这样可以确保参数中存在的空格不会被解释为分隔符。
- ``set -- "${ARGS}"`` 将 ${ARGS} 中的字符串按照空格进行拆分，并将拆分后的结果设置为脚本的位置参数。
  位置参数是脚本中可用于访问传递到脚本的参数的特殊变量，它们被存储在 $1、$2、$3 等变量中。
  注意: **此时的结果是一个整体字符串, 还需要使用eval才能将其拆分为正常的多个参数字符串**
- eval 命令用于执行由 ``set -- "${ARGS}"`` 生成的命令，将其作为有效的Shell命令执行。
  通过使用 eval 命令，我们可以将 ${ARGS} 中的字符串解析为实际的命令行参数，以便在脚本中使用这些参数进行进一步的处理或操作。
