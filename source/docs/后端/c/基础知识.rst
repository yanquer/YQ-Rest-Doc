=====================
基础知识C(++)
=====================


.. post:: 2023-02-20 22:06:49
  :tags: c
  :category: 后端
  :author: YanQue
  :location: CD
  :language: zh-cn


结构体
=====================

定义
---------------------

定义::

	struct $tag {
		$c_type arg1;
		$c_type arg2;
		...
	} arg_list;

- struct 是关键字表示定义结构体
- tag 是结构题标签, 相当于Python的类
- c_type arg1 表示定义结构题内具体的成员变量, 比如 `int x`
- arg_list 是当前结构体变量名, 可以为多个. 可以理解为 tag 标签实例化了多个类

.. note::

	结构体标签, 成员变量定义, 结构题变量名. 定义时, 至少需要其中两个, 否则错误.


如, 以下声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c::

	//结构体的标签被命名为SIMPLE,没有声明变量
	struct SIMPLE
	{
		int a;
		char b;
		double c;
	};
	//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
	struct SIMPLE t1, t2[20], *t3;

等价与::

	struct SIMPLE
	{
		int a;
		char b;
		double c;
	} t1, t2[20], *t3;

初始化
---------------------

初始化::

	#include <stdio.h>

	struct Books
	{
		char  title[50];
		char  author[50];
		char  subject[100];
		int   book_id;
	} book = {"标题", "作者", "C", 1111};

	// 访问使用 . , 如 book.book_id

访问
---------------------

结构体本身用 . 访问
结构题指针用 -> 访问


用例:

.. literalinclude:: ../../../../.test/test.cpp
	:caption: c示例
	:language: c++



typedef
=====================

重新定义已有变量、类型等

char数组赋值
=====================

初始化直接赋值::

	char a[20] = "hello";

数组逐个赋值::

	char a[20] = {'h', 'e', 'l', 'l', 'o'};

strcpy拷贝赋值::

	char a[20];
	strcpy(a, "hello")

其他::

	char const *se = "hello";

等价与::

	char const *see;
	see = "hello";

.. note::

	`char const *se = "hello";` 需要加 const 是因为char表示字符常量, 不允许被修改.

单/双引号
=====================

- 单引号引用单个字符, 表示字符字面量, 占用一个字符, 代表整数, 整数值对应于该字符在编译器采用的字符集中的序列值(一般编译器采用的都是ASCII字符集)
- 双引号引用字符串常量, 表示字符串字面量, 占用为所有字符个数加一, 因为每个字符串末尾自动会加上一个空字符 '\0', 代表字符指针, 指向字符数组首地址. 如 `"a"+1` 表示指针运算, 指向结束符 '\0'.
- 空字符常量 '\0'
- 空白字符串 ""

指针
=====================

指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在３２位平台下，指针默认为３２位。。

指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型::

	int *p ;	//p 变量保存的地址所在内存单元中的数据类型为整型

	float *q;	// ... 浮点型

不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。

C语言中定义一个变量时可以初始化::

	char str[10] = {"hello world"};

当编译器遇到这句时，会把str数组中从第一个元素把hello world\0 逐个填入。。

C语言中规定数组代表数组所在内存位置的首地址，也是 str[0]的地址，即::

	str = &str[0];

而printf("%s",str); 为什么用首地址就可以输出字符串, 因为这里给的也是地址. 即打印出的结果为变量地址所指向的值.

比较打脑壳的情况::

	char *s ;
	s = "China";

	// 可以编译通过, 因为这里赋值实际还是赋值的首地址
	// "China" 是一个字符串, 若用变量表示指向即为其首地址, 这里把首地址赋值给s (打印出来也是首地址而非"China")

几个不同概念

- char \*a : 保存字符串首地址的指针变量
- char a[] : 字符数组
- char \*a [] : []的优先级高于*, 所以a先和 []结合, 他还是一个数组, 数组中的元素才是char *
- char \*\*a  : 二级指针, 表示一级指针 的地址

.. note::

	char* a 等价与 char \*a, 都是表示指针

	不过如果一起定义两个指针只能这样写::

		char *a, *b

特殊符号 #
=====================

在C(++)中, #表示预处理或者预编译(正式编译前的处理, 非编译).

.. note::

	C语言程序从编写到运行要经过预处理、编译、汇编和链接这 4 个阶段


#define(宏定义)
---------------------

定义普通常量
+++++++++++++++++++++

定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。

用 #define 定义标识符的一般形式为::

	#define  标识符  常量   //注意, 最后没有分号

作用范围为当前源文件, 若要终止使用宏定义, 用::

	#undef  标识符

表示不再使用宏替换

.. note::

	宏定义的标识符一般大写, 末尾不加分号, 且支持定义嵌套


带参数替换
+++++++++++++++++++++

例::

	#define S(a,b) a*b

	area=S(3,2);

第一步被换为area=a*b; 第二步换为area=3*2;

.. note::

	注意宏替换只做替换, 不求解.

	宏展开不占用运行时间，只占用编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）

双#表示连接
+++++++++++++++++++++

##是连接符号

例::

	#define Conn(x,y) x##y

表示x与y连接, 如::

	int n = Conn(123,456);

结果就是n=123456;

表示转换字符#@
+++++++++++++++++++++

“#@”表示转换字符(结果加上单引号), 结果返回constchar类型

例::

	#define ToChar(x) #@x

如::

	char a = ToChar(1);

结果就是a='1';

做个越界试验::

	char a = ToChar(123);

结果是a='3';

但是如果你的参数超过四个字符，编译器就给给你报错了！error C2015:too many characters in constant ：P


转换字符串单#
+++++++++++++++++++++

#是替换为字符串

例::

	#define ToString(x) #x

若定义::

	char* str = ToString(123132);

就成了str="123132";

.. note::

	可以使用 ifndef 来避免重复定义宏::

		#ifndef __headerfileXXX__
		#define __headerfileXXX__
		…
		code
		…
		#endif

c++虚函数
=====================



被virtual关键字修饰的成员函数，就是虚函数. 作用是为了实现多态(将接口与实现分离)

借用百度百科的例子::

	#include<iostream>
	using namespace std;

	class A
	{
		public:
			virtual void print(){cout<<"This is A"<<endl;}
	};
	class B : public A
	{
		public:
		void print(){cout<<"This is B"<<endl;}
	};

	int main1()
	{
		A a;
		B b;
		a.print();
		b.print();
		return 0;
	}

	int main2()
	{
		A a;
		B b;
		A *p1 = &a;
		A *p2 = &b;
		p1->print();
		p2->print();
		return 0;
	}

.. sidebar::

	此例中, 如果父类print不是定义的虚函数, 那么main2函数打印结果都是 This is A.

只要基类是虚函数, 那么派生类继承此虚函数的, 不管是否有关键字virtual, 都是虚函数. 因为如果没有写关键字, 编译器会自动帮你加上.

:参考:: https://baike.baidu.com/item/虚函数#:~:text=在某基类中声明为%20virtual%20并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual,函数返回类型%20函数名（参数表）%20%7B函数体%7D；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数%E3%80%82


另外一个问题, 虚函数的继承要保持一致, 如, 以下两个定义是不等价的::

	virtual void func()const

	virtual void func()

虚函数的声明与定义要求非常严格，只有在子函数中的虚函数与父函数一模一样的时候（包括限定符）才会被认为是真正的虚函数，不然的话就只能是重载。这被称为虚函数定义的同名覆盖原则，意思是只有名称完全一样时才能完成虚函数的定义。


内存分区
=====================

内存分5个区：全局名字空间，自由存储区，寄存器，代码空间，栈

大端/小端
=====================

- 大端: 较低的有效字节存放在较高的存储器地址中，较高的有效字节存放在较低的存储器地址
- 小端: 较高的有效字节存放在较高的存储器地址中，较低的有效字节存放在较低的存储器地址

栈的地址分配是从高->低,堆的地址分配是从低->高.

.. 以10000为例
.. 	如果我们定义两个连续的10000 (即 ``0x2710``) ，内存中的表示方式可能如下所示：

.. 	第一个10000：10 27 00 00
.. 	第二个10000：11 27 00 00

.. 	可以看到，第二个10000的第一个字节变为了"11"，而其他字节保持不变。

.. 	这是因为在小端序中，较低的内存地址存放较低位的字节。
.. 	当定义多个连续的10000时，每个10000的低位字节会存储在前一个10000的高位字节后面。


.. 	大端序好像没有这个问题, 且好像只有一个是纯数字, 一个在数组里面才会遇到

.. 忽略, 上面的问题 是写错了
