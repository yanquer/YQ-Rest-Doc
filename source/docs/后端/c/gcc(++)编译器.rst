============================
gcc/g++
============================

最浅显是认识是:

- gcc 用于 c 语言
- g++ 用于 c++

但是这个认识是错的, 也不说全错, 正确的认识是: `g++以及gcc的区别 <https://zhuanlan.zhihu.com/p/100050970>`_

大致:

- GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C等语言。

  - Compiler 编译程序，gcc/g++/cc 用来编译源代码文件，通常通过 gcc 调用 g++ 或 cc 命令；
  - Assemblers 汇编程序，编译汇编程序，通常通过 gcc 调用 as 命令；
  - Linkers 链接程序，用来链接编译输出的目标文件，生成可执行程序，通常通过 gcc 调用 ld 命令，还有 ar 命令生成链接库；

	GCC 编译套件不仅支持 C/C++，支持各种 C/C++ 方言标准，还支持 Go 或 Object-C/C++ 等，并且支持 x86、x86_64、ARM 等多种 CPU 架构。提供 `gcc` 命令相当于一个门户，它本身就是 C 语言编译器，并且通过它可以调用整个编译流程中会使用到的各种命令。它可以识别各种 C/C++ 源文件的扩展名，并将相应参数传给相应的命令，如果是 C++ 源代码，则执行 `g++` 命令。

	另外，`cc` 是 Unix 系统的 C Compiler，一个是古老的 C 编译器命令。Linux 的 cc 一般是一个符号连接，指向 gcc，可以通过 `ls -l /usr/bin/cc` 来查看。

	注意，直接使用 `g++` 编译 C 语言源代码会被当作 C++ 源代码处理。

	例如，编译 C 语言为汇编程序，不生成目标文件和可执行程序，只需要执行命令时使用 `-S`：

- gcc是GCC中的GUN C Compiler（C 编译器）

- g++是GCC中的GUN C++ Compiler（C++编译器）

gcc和g++的主要区别:

- 对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）

- 对于 *.c和*.cpp文件，g++则统一当做cpp文件编译

- 使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL

- gcc在编译C文件时，可使用的预定义宏是比较少的

- gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏。

- 在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个。

gcc 选项
============================

-I<dir> 	指定头文件所在目录, 会优先找此处指定的目录
-l<dir> 	指定库路径. 指定需要链接的库名，用于告诉链接器需要链接哪些库文件
-L<dir> 	指定库文件所在目录
-fno-lto  禁用链接时优化（LTO）
					当使用该选项编译源代码时，编译器将不会进行链接时优化，
					这可能会导致一些性能上的损失，但也可以避免某些链接错误。

.. note::

	`-fno-lto` 主要用于使用的链接文件是由其他版本LTO的gcc编译时导致无法继续编译时候吧

网上看到一篇不错的说明: `gcc命令行详解 <https://blog.csdn.net/casularm/article/details/316149>`_

.. _gcc_相关环境变量:

gcc 相关环境变量
============================

CC
----------------------------

**CC**

在Linux系统中，CC是一个环境变量，用于指定默认的C编译器。
当你在终端中输入gcc命令时，实际上是使用了CC环境变量中指定的编译器。
CC环境变量通常被设置为gcc或clang等编译器的路径，例如：

	CC=/usr/bin/gcc

这表示默认使用GCC作为C编译器。如果你想使用Clang作为C编译器，则可以将CC环境变量的值设置为Clang的路径。

.. note::

	修改CC环境变量可能会影响整个系统的行为。因此，在更改它之前，请确保你知道自己在做什么，并且进行充分的测试和确认。

如果你想修改GCC运行时默认添加的参数，可以使用环境变量 CFLAGS_ 和 LDFLAGS_

CFLAGS
----------------------------

CFLAGS环境变量用于 **指定编译器（例如gcc）的默认编译选项**.
它通常包含一系列的标志，例如优化级别、调试信息等等。
如果你想添加或修改默认的编译选项，可以设置CFLAGS环境变量。例如::

	CFLAGS="-O3 -Wall"

这里将优化级别设置为-O3，并启用所有警告信息（-Wall）。需要注意的是, **修改CFLAGS环境变量会对整个系统生效**

LDFLAGS
----------------------------

LDFLAGS环境变量用于 **指定链接器（例如ld）的默认链接选项**.
它通常包含一系列的标志，例如库文件路径、静态链接选项、动态链接选项等等。
如果你想添加或修改默认的链接选项，可以设置LDFLAGS环境变量。例如::

	LDFLAGS="-L/path/to/library/files -lmymath"

这里将库文件路径设置为/path/to/library/files，并链接一个名为libmymath.so的共享库文件。
需要注意的是，修改LDFLAGS环境变量会对整个系统生效。

需要注意的是，在设置CFLAGS和LDFLAGS环境变量时，应该尽可能避免重复的标志。如果同一个标志被多次指定，可能会导致编译或链接错误。

头文件相关环境变量
============================

在Linux中, 有四个环境变量可以用来设置预处理阶段头文件搜索路径:

- C_INCLUDE_PATH（用于C语言）
- CPP_INCLUDE_PATH（用于C++）
- CPATH（都可以用）
- OBJC_INCLUDE_PATH

注意Linux中, 它们的取值可以是一组用:分割开的地址列表, 类似于环境变量PATH

pkg-config
============================

当需要指定的头文件目录非常多时, 全部写在参数就非常麻烦, 于是可以用: pkg-config

示例, 查看头文件库文件路径::

	yanque@yanquedembp ~ % pkg-config --cflags glib-2.0
	-I/usr/local/Cellar/glib/2.70.4/include/glib-2.0 -I/usr/local/Cellar/glib/2.70.4/lib/glib-2.0/include -I/usr/local/opt/gettext/include -I/usr/local/Cellar/pcre/8.45/include
	yanque@yanquedembp ~ %
	yanque@yanquedembp ~ % pkg-config --libs glib-2.0
	-L/usr/local/Cellar/glib/2.70.4/lib -L/usr/local/opt/gettext/lib -lglib-2.0 -lintl

ld与gcc联系
============================

ld和C编译器（如gcc）都是GNU编译工具链的一部分，但它们的作用有所不同。

**C编译器主要用于将源代码编译成目标文件**，这些目标文件可以是机器码或汇编代码。
在编译源代码过程中，C编译器会对代码进行语法分析和类型检查，并生成可执行文件所需的符号表、重定位表等信息。
同时，C编译器还会将源代码中使用到的库文件链接到可执行文件中，以便程序能够正确地运行。

**链接器（ld）则主要用于将多个目标文件链接成一个可执行文件或共享库**。
在链接过程中，链接器会根据符号表和重定位表等信息，将不同的目标文件合并为一个整体，
并解决各种符号引用和地址重定位问题，最终生成可执行文件或共享库。

需要注意的是, **在Linux系统中, 链接器通常由C编译器自动调用**。
也就是说，在编译源代码时，C编译器会自动调用链接器来生成可执行文件。因此，在使用gcc编译时，你无需手动调用链接器。

msvc
============================

与gcc类似, 是msvc 微软的一个闭源编译器, 仅支持Windows,
也不支持高版本的语言特性/标准, 不过提供了与编译头文件等技术加快编译速度

编译后的文件说明
============================

- .a文件, 静态库文件
- .o文件, 对象文件, 目标文件
- .so文件, 共享库文件

一般使用g++编译, 默认生成的就是 `.o` 文件, 表示一个对象文件,
是单个源代码文件编译后的结果. 需要在链接过程中和其他 `.o` 文件或者库文件链接到一起,生成可执行文件.
用于动态链接,生成可执行文件较小但运行时还需要原来的 `.o` 文件.
动态链接的优点是可执行文件较小, 运行时对环境依赖性更强.

`.a` 文件由多个 `.o` 文件聚合而成, 用于静态链接, 生成可执行文件较大但运行时不需要 .a 文件.
静态链接的优点是运行更快,但可执行文件较大.

如将当前目录下所有 `.o` 文件打包为静态库文件(`.m` 文件)::

	ar -rc res.m *.o

ar使用可见 :doc:`/docs/操作系统/linux/linux指令/ar`




