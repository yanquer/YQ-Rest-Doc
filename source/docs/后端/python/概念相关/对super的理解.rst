=========================
对super的理解
=========================

前言
=========================

Python的super常用于继承. 关于继承, 又不得不提到经典类与新式类.

- Python2.x 都是经典类
- Python3.x 是新式类, 注意需要继承自 object

对于子类的某一个调用, 经典类会深度优先搜索的区寻找执行, 而新式类是广度优先搜索执行
(这里有个坑, 算不上真正的广度优先, 实际上主要还是参考MRO的实现, 不过最后一个找的一般都是object,
或者说公共父类往往在此父类所有子类都找了后再找).

关于方法的执行顺序, 可以调用其 ``_mro_`` 属性(method resolution order)查看继承顺序.


.. note::

    关于 MRO的实现, 在网上看到一篇还可以的解释: `MRO的实现, <https://zhuanlan.zhihu.com/p/268136917#:~:text=python的类分为两种类型%3A%20经典类%20%28python2的默认类%29和%20新式类%20%28python3的默认类%29，经典类在继承的时候采用%20深度优先,的顺序，而新式类的继承顺序则采用%20广度优先%20%28从左到右%29的顺序%E3%80%82%20在python3中继承可以直接写成%20super%20%28%29.方法名%20%28参数%29>`_

    可略微参考, 最后的计算看起有点问题. 更具体的还是去参考官方了.

    新式类的搜索顺序更像是先深度, 但是把 object 这种公共顶层 放最后.

super使用
=========================

在继承时, super可用于实现父类方法

.. code-block:: python

    class A(object):
        def eat(self):
            print('A eat')

    class B(A):
        def eat(self):
            # 此处 super().eat() 与 super(B, self).eat() 效果一致
            super().eat()
            print('B eat')


.. note::

    super 如果带参数, 实际测试只有 ``($class, self)`` 的形式才有效果, 会从 ``$class`` 开始向上找基类方法执行.

    另外必须使用 super() 的形式, 也就是必须用其对象, 否则会报错没有属性.





